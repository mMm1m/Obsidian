Локальная система контроля версий позволяет хранить записи о всех изменениях в файлах, осуществляя тем самым контроль ревизий. Одной из популярных СКВ была система RCS, которая и сегодня распространяется со многими компьютерами. RCS хранит на диске наборы патчей (различий между файлами) в специальном формате, применяя которые она может воссоздавать состояние каждого файла в заданный момент времени.
![[ЛокальнаяСКВ.png.png]]
Централизованная система контроля версий позволяет нескольким разработчикам подключаться к одному централизованному серверу и получать из него необходимые данные. Проблемы очевидны и связаны с невозможностью получения данных при отказе сервера. Наиболее известным представителем является Subversion.
![[Pasted image 20240205074655.png]]
Распределённые системы контроля версий( Git ,  Mercurial) - СКВ в которых клиенты полностью копируют репозиторий. Более того, многие РСКВ могут одновременно взаимодействовать с несколькими удалёнными репозиториями, что позволяет использовать разные подходы в одном проекте.
![[Pasted image 20240205075155.png]]
(Минутка определений): Патч - обновление или дополнение к программе, также "набор патчей" обозначает различия между файлами.

Переключаемся сугубо на git:
Данные в git хранятся как набор снимков относительно первоначального значения. 
![[Pasted image 20240205075838.png]]
В Git для всего вычисляется хеш-сумма, и только потом происходит сохранение. В
дальнейшем обращение к сохранённым объектам происходит по этой хеш-сумме. Это
значит, что невозможно изменить содержимое файла или каталога так, чтобы Git не узнал
об этом(конкретнее здесь используется SHA-1 хеш, это строка длиной в 40 шестнадцатеричных символов (0-9 и a-f), она вычисляется на основе содержимого файла или структуры каталога.)

У Git есть три основных
состояния, в которых могут находиться ваши файлы: изменён (modified), индексирован
(staged) и зафиксирован (committed):
• К изменённым относятся файлы, которые поменялись, но ещё не были зафиксированы.
• Индексированный — это изменённый файл в его текущей версии, отмеченный для
включения в следующий коммит.
• Зафиксированный значит, что файл уже сохранён в вашей локальной базе.
Мы подошли к трём основным секциям проекта Git: рабочая копия (working tree), область
индексирования (staging area) и каталог Git (Git directory).
![[Pasted image 20240205080511.png]]
Для сохранения изменения версий необходимо инициализировать git-репозиторий, для этого необходимо использовать команду git init. Банально? Донельзя. Идём дальше ->
git add позволяет индексировать файлы для последующего коммита. 
git commit фиксирует изменения . Базовое трио команд.
Так как git - распределённая, каждому клиенту необходимо получать экземпляр, для этого используем команду : git clone "ссылка на ресурс". 
Итак, имеем рабочее пространство, есть ресурс который необходимо изменить - самое время описать жизненный цикл файлов, представимый в одной картинке:

![[Pasted image 20240205095428.png]]
Существуют также .gitignore файлы, они необходимы в том случае если мы не хотим добавлять в окончательный коммит различные автоматически-генерируемые файлы, например при компиляции кода на c++ генерируются объектные файлы, принимающие участие в последующей линковке, но нам, как разработчикам, важен только код в .cpp и .h файлах, так что .o файлы не будут добавлены в коммит. Определять, какие файлы добавлять или не добавлять нам позволяют скрипты(как пример. Ну и синтаксис такой же как в регулярных выражениях):

'#' Исключить все файлы с расширением .a
*.a
'#' Но отслеживать файл lib.a даже если он подпадает под исключение выше
!lib.a
'#' Исключить файл TODO в корневом каталоге, но не файл в subdir/TODO
/TODO
'#' Игнорировать все файлы в каталоге build/
build/
'#' Игнорировать файл doc/notes.txt, но не файл doc/server/arch.txt
doc/*.txt
'#' Игнорировать все .txt файлы в каталоге doc/
doc/**/*.txt

git diff - команда используемая для просмотра измененных, но не проиндексированных файлов или проиндексированных , но не закомиченных. В общем расширяет функционал git status.
В некоторых случаях можно пропустить этап индексации и сразу перейти к коммиту:
git commit -a -m "New commit"

Чтобы удалить файл из индексации, используйте git rm файл. Таким образом он станет неотслеживаемым. Если же просто удалить файл , он будет показан в секции
«Changes not staged for commit» (измененные, но не проиндексированные), т.е. git буквально сломается. Чтобы удалить файл из  индексации , но оставить его в  рабочем каталоге используйте:
git rm --cached file
Если передать качестве параметров катологи или шаблоны используйте экранирование(\).
Как и в линуксе для переименования файла используется:
git mv file_from file_to
Если вы слишком привередливы и дотошны до формата вывода коммита, то для таких как вы существует параметр pretty, позволяющий например выводить коммит в одну строку или например изменять формат вывода и выводить только необходимое:
git log --pretty=oneline

git log --pretty=format: "%h - %an, %ar : %s"

git в первую очередь нужен для добавления и уже во вторую - для удаления, но чтобы не загромождать историю коммитов лишней информацией используем следующий вариант:
git commit -m "Commit"
git add forgotten_file
git commit --amend
Таким образом вместо двух коммитов окажется только последний. Можно также исключить некоторые файлы из индекса, это можно сделать следующим образом:
git reset HEAD <file>
Также добавлена возможность удаления файла из индекса с помощью git restore:
git restore --staged Delete.h
Небольшое замечание о том, что заметил только сейчас, в командах удаления в качестве параметров можем использовать тот уровень, с которого хотим убрать файл.
[[Pasted image 20240205095428.png]]

В основном приходится взаимодействовать с удалёнными репозиториями , получать из них информацию и отдавать изменённую .Для того, чтобы добавить удалённый репозиторий и присвоить ему имя (shortname), просто выполните команду 
git remote add <shortname> <url>
Теперь вместо полного пути можно использовать <shortname>. Для получения подробной информации можно использовать параметр show <remote name>.
Чтобы получить все данные, которые есть на удалённом репозитории , используем
git fetch <shortname>
Данная команда связывается с указанным удалённым проектом и забирает все те данные
проекта, которых у вас ещё нет. Важно отметить, что команда git fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не
модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить
эти данные с вашими, когда вы будете готовы.

Если ветка в локальном репозитории настроена на отслеживание ветки в удалённом , то можно использовать команду git pull ; она выполняет то же самое, что и git fetch , но помимо вытягивания данных сливает ветку с текущей. 

Ну и для отправки коммитов на удалённый репозиторий используется git push.
git push <remote-name> <branch-name>
В качестве небольшой хитрости можно использовать псевдонимы ,  они настраиваются с помощью git config и позволяют выбрать область применения.
git config --global alias.ch checkout

Перед ветвлением: в нём используется модель указателей на ветки. Самая известная и наиболее часто применяемая - HEAD - является указателем на текущую ветку, которая, в свою очередь, является указателем на последний коммит, сделанный в этой ветке.