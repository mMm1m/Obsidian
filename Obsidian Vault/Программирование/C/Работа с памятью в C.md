Указатель - адрес фрагмента памяти. Они помогают сделать данные разделяемыми и избегать копирования. Для получения адреса переменной в памяти нужно использовать '&' , является альтернативным именем для существующей переменной(например 0x3E8FAO).
В C аргументы функции передаются по значению , поэтому чтобы изменять не локальную переменную нужно вызывать указатели на аргументы, так содержимое будет изменяться по адресу в памяти.
Использование указателей в памяти:
1) Узнать местоположение переменной в памяти : &x
2) Создание ссылочной переменной:
int * address_of_x = &x;
Получить содержимое по адресу :
int val = * address_of_x;
3) Изменение содержимого хранящегося по адресу: 
\* address_of_x = 90;
При передачи массива в качестве аргумента функции компьютер связывает адрес первого символа с переменной, поэтому вызов sizeof(msg) по следующей сигнатуре 
void fortune(char[] msg){...}
вернет 8 байтов(столько необходимо для хранения одного указателя в 64-разрядной системе).

Некоторые нюансы , связанные с переменными массивов и указателями:
1) sizeof(массив) - размер массива , а не указателя на первый элемент.
2) Адрес массива равен переменной массива , а вот для адресации указателя такое не работает.
3) Переменные массивов не могут указывать ни на что кроме созданного массива.
fgets(char\* *, int , stdin) - аналог scanf

Ну и вообще можно приводить простой тип данных к указателю на этот простой тип данных и разыменовывая получать значение , лежащее по искомому адресу, т.е.:
```c
int x = 5;
int y = *((*int)x);
```
Если тип значения неизвестен, можно привести к указателю на void:
```c
#include <stdio.h>

int main() {
	void *p = NULL;
	int intVar     = 10;
	char charVar   = 'A';
	float floatVar = 24.3;
	float *floatPtr = NULL;

	p = &intVar;
	*((int*) p) = 20;
	printf("intVar = %d\n", intVar);

	p = &charVar;
	printf("charVar = %c\n", *((char*) p));

	p = &floatVar;
	floatPtr = (float*) p;
	printf("floatVar = %.3f", *floatPtr);

	getch();
}
```

Ссылки: [[Введение в C]]



