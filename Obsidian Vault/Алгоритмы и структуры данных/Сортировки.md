1) Сортировка вставками:
Идея в том, что в каждой итерации префикс до текущего индекса отсортирован. То есть двигаем элемент влево, пока он не встанет на нужную позицию. 

for i = 0...n-1
   j = i
   while(j > 0 && a[j] < a[j-1])
      swap(a[j], a[j-1])
      --j;

В худшем случае: O(n^2)
В лучшем случае: $\omega$(n)

Рекурсивные функции:
f(n):
   if(n == 1)
      return 1
    else return f(n-1)

f(n) -> f(n-1) -> ... -> f(1)
Время: O(n)

f(n):
   if(n == 1)
      return 1
    else return f(n/2)

f(n) -> f(n/2) -> ... -> f(1)
Время: O(logn)

f(n):
   if(n == 1)
      return 1
    else return f(n/2)+f(n/2)

f(1) <- ... <- f(n/2) <- f(n) -> f(n/2) -> ... -> f(1)
Время: O(2^(log_2(n)) = n) 

2) Сортировка слиянием:
Делим массив пополам , рекурсивно запускаем каждую половину и в итоге получаем два отсортированных массива.

merge(a[], b[])
   i = 0,j = 0
   c = []
   while(i < len(a) || j < len(b))
      if(j == len(b) || i < len(a) && a[i] < b[j])
         c[i+j] = a[i++]
      else c[i+j] = b[j++]
   return c; 

Время merge(): O(n)

sort(a[])
   n = len(a)
   if(n <= 1)
      return a;
   l = a[0...n/2-1]
   r = [n/2...n-1]
   l = sort(l)
   r = sort(r)
   return merge(l,r)

Время работы: T(n) = 2T(n/2)+ n = O(nlogn)

Лайфхак: время работы рекурсивного алгоритма равно площади рекурсивного дерева.

Мастер-Теорема:
Берём некоторую задачу, делим её на a кусков и рекурсивно выполняем b раз.
T(n) <= bT(n/a) + n^c - разбиение и сборка

Время работы: если c < log_n(b) T(n) = n^log_a(b) , c >  log_n(b) T(n) = n^c,
c =  log_n(b) T(n) = n^c logn
3) Сортировка кучей:
Положим элементы в кучу и достанем их оттуда
 for i  =0...n-1
    insert(a[i])
for i = 0...n-1
   a[i] = get_min()
   return min();
   Time: O(logn)

Улучшение по памяти: 
a - наш массив , h - массив кучи
Идея в том, чтобы использовать только один массив,выполняя просеивание и получая наименьший элемент
for i = 0...n-1
   sift_up(i) // heapify(создание кучи из массива)
for i = 0...n-1
   remove_min()
Time: O(nlogn)

Аналогично можно просеять элементы снизу вверх, пройдя от конца до начала массива
for i = n-1...0
   sift_down(i)
for i = n-1...0
  remove_min()
  Time:O(n)

Cсылки: [[Асимптотика]]